# March 25, 2019

## Q&A

### Seq: desugar or not?

If you desugar into `let`s, it will create extra stack slots in order to store garbage. This can result in a higher minimum memory bound than expecting because if it's bound, it can't be garbage collected.

### Final project

Go to office hours some time this week to scope out project.

Possible projects:

* strings
* some kind of optimizations
    * get rid of "many" unnecessary moves
* objects
    * something like dictionaries
    * something like dynamic dispatch
    * constructors, state, inheritance, visibility, etc are all optional
    * implement objects as closures
* modules...?
    * circular dependencies?
    * multiple includes?
    * separate compilation?
    * imports shadowing?
    * ...many more
* specialization/monomorphization
    * could be huge
* foreign function interface
* retargeting compiler to web assembly
    * porting garbage collector to web assembly
* threading, coroutines, generators
* (non-trivial) macros
    * e.g., hygienic macros
* exceptions (e.g., option type)

## Optimization

We will need more info than just a tree to optimize...

### Compile-time arithmetic

```
let n = 5 + 5 in
let m = 2 * 2 in
let x = n + 1 in
let y = m + 2 in
    x + y
```

It's very clear we can do all this arithmetic at compile time.

What if we change m...

```
let n = 5 + 5 in
let m = z * z in
let x = n + 1 in
let y = m + 2 in
    x + y
```

The answer is `11 + y`, which means we can still get rid of `x` and `n`.

### Using registers instead of stack for intermediate values

How many registers would I need to evaluate this?

```
let n = 5 + 5 in
let m = 2 * 2 in
let x = n + 1 in
let y = m + 2 in
    x + y
```

How do we find this systematically?


```
let n = 5 + 5 in (* no variables defined *)
let m = 2 * 2 in (* n *)
let x = n + 1 in (* n, m *)
let y = m + 2 in (* m, x *)
    x + y        (* x, y *)
```

We look at the lifetimes of the variables and look for overlaps.

`m` and `n` better not be in the same register because we need both of theme to exist. `x` conflicts with both `m` and `n` (but a more refined version of this analysis would distinguish between the set that are defined, used, and killed at a specific site. In that case, `x` would not conflict with `m` and `n`).

**Conflict graph:**

```
m ------ n
|  \   /
|    x
|  /   \
x ------ y
```

We need to solve the n color, where n is the number of registers we have open. We need at least 3 registers because we have a clique of size 3.

**Trimmed Conflict graph:**

```
m ------ n
|
|
|
x ------ y
```

Now we can have just 2. But let's look at the original conflict graph for now.

**Bad news: this algorithm is NP complete.**

Let's use this heuristic: color the highest degree first because it applies the most constraints. This will fail sometimes because it's a greedy algorithm. This is ok because we can just use the stack as spill over space when it fails.

This is intrinsically a graph algorithm so we can't just use a tree to represent.

Ok, we've figured out how we can just put intermediate values in registers and we've used all of them. Now, we need to do a tag check. Where will we put that new intermediate value?

One method is  to just push any register on to the stack and use that register and restore after. This could cause very inefficient compiled code.

Another method is to include all the tag check registers into the conflict graph. For all expressions in our program, we create the conflict graph. This is more consistent.

This method uses only the structure of our compiled code and not any property about the meaning of the code.